# Rules

A rule consists of four parts:

* Targets: a list of values that are generated by this rule.
* Prereqs: a list of values that must be generated before this rule can be
  executed.
* Attributes: a list of flags that customize how this rule is interpreted.
* Recipe: a list of commands that are run to execute the rule.

The syntax for a rule is

```
targets:attributes: prereqs
    recipe
```

If the rule has no attributes, it may be omitted, leaving just `targets:
prereqs` on the first line.

When a rule is embedded in Lua, it is prefixed with a `$`:

```
$ targets:attributes: prereqs
    recipe
```

Direct rules are rules where the targets and prereqs are explicit names of
values. For example,

```
foo.o: foo.c
    gcc -c foo.c -o foo.o
```

Specifies that the file `foo.o` is built from `foo.c`, using the command `gcc
-c foo.c -o foo.o`.

## Meta rules

A meta rule is a special rule that describes a generic way to create direct
rules.  The meta rule describes how to match targets and prereqs into a direct
rule.  For example, a `%` meta rule uses `%` to match any sequence of
characters.

Thus the meta rule

```
%.o: %.c
    ...
```

describes that a direct rule

```
foo.o: foo.c
    ...
```

could be created. This direct rule would be created if another rule needed
`foo.o` to be generated.

Meta rules may also specify the match by using regular expressions, if the `R`
attribute is provided. For example:

```
foo-(.*)-(.*).tar.gz:R: $1/$2/foo
    ...
```

could create a direct rule

```
foo-linux-amd64.tar.gz: linux/amd64/foo
    ...
```

## Attributes

Knit supports the following attributes:

* `Q` (quiet): do not print this rule's recipe when executing.
* `R` (regex): this meta rule uses regular expression matching.
* `V` (virtual): the value this rule generates is not a file, just a name.
* `M` (no meta): this rule's targets cannot be matched by meta rules.
* `E` (non-stop): this rule does not stop if one of its commands fails.
* `B` (build): this rule must always be built (it is always out-of-date).
* `L` (linked): this rule always runs if an out-of-date sub-rule requires it as
  a prereq.

## Recipes

A recipe is a list of commands to execute. They are executed within the `sh`
shell. Recipes may use variables that will be expanded before the recipe
executes. Variables are written with `$var`, or full Lua expressions can be
written with `$(expr)`. Variables/expressions are expanded eagerly when the
rule is created. If expansion causes an error, the expansion is delayed until
rule evaluation (when special build variables are available). During rule
evaluation, only global variables (and special variables) are available.

Some special variables are available during recipe expansion:

* `input`: a string of rule's prereqs.
* `inputs`: an array of this rule's prereqs.
* `output`: a string of this rule's targets.
* `outputs`: an array of this rule's targets.
* `match`: the value captured with `%` in a meta rule.
* `matches`: a list of matches captured by a regular expression meta rule.

# Knitfiles

A Knitfile is a Lua 5.1 program with additional support for rule expressions.
The Knitfile ultimately must return a "ruleset" -- a list of build rules that
are used to construct the build graph.

```
$ targets:attributes: prereqs
    ...
```

A rule expression may be assigned to a variable

```
local rule = $ foo.o: foo.c
    gcc -c $input -o $output
```

More often, rule expressions are gathered together in a Lua table:

```
local rules = {
$ foo.o: foo.c
    gcc -c $input -o $output
$ foo: foo.o
    gcc $input -o $output
}
```

## Rulesets

A table of rules can be converted into a "ruleset" by using the special `r`
function, which converts the table into a Lua "userdata" object representing a
list of build rules.


```
local ruleset = r{
$ foo.o: foo.c
    gcc -c $input -o $output
$ foo: foo.o
    gcc $input -o $output
}
```

If the Knitfile returns this ruleset, then it will be used as the main set of
rules for the build.

Note that two rulesets may be combined with the `+` operator.

```
ruleset = ruleset + r{
$ build:V: foo
}
```

## Sub-builds

A build may use several rulesets. In addition, when depending on another ruleset,
you may specify the directory the ruleset should be executed in. The ruleset dependency
is specified in the form `[ruleset][directory]rule`.

For example:

```
local foorules = r{
$ foo.o: foo.c
    gcc -c $input -o $output
}

return r{
$ prog.o: prog.c
    gcc -c $input -o $output
$ prog: prog.o [foorules][libfoo]foo.o
    gcc $input -o $output
}
```

This Knitfile assumes the build consists of `prog.c` and `libfoo/foo.c`. It
builds `libfoo/foo.o` using a sub-build and a separate ruleset that is executed
from within the `libfoo` directory.

It is also useful to combine sub-builds with the `include(kf)` function, which
runs the Knitfile `kf` from the directory where it exists, and returns the
ruleset that the Knitfile produces. This means you can easily use a sub-directory's
Knitfile to create a ruleset for use in a sub-build.

# Options

Knit will search the current directory for a Knitfile called `knitfile` or
`Knitfile`. If one is not found, it will use the Knitfile in
`~/.config/knit/Knitfile.def`, or if that does not exist it will throw an
error.

Several options are available as command-line flags. They may also be specified
in a `.knit.toml` file. Knit will search upwards from the current directory
for `.knit.toml` files, and use the options set in those files. It will also
search `~/.config/knit/.knit.toml`.

## Sub-tools

Running `knit [TARGET]` will create a build graph for the target. By default,
knit will then execute that build graph. Using the `-t TOOL` option, you may
specify a sub-tool to run instead of building:

* `list` - list all available tools
* `graph` - print build graph in specified format: text, tree, dot, pdf
* `clean` - remove all files produced by the build
* `targets` - list all targets (pass 'virtual' for just virtual targets)
* `compdb` - output a compile commands database
* `commands` - output the build commands (formats: knit, json, make, ninja, shell)
* `status` - lists dependencies and whether they are up-to-date

The special target `_all` depends on every target in the build. Thus `knit _all
-t targets` will list all targets.

Some examples are shown below.

### Automatic cleaning

```
knit target -t clean
```

### Output a shell script for the build

```
knit target -t commands shell
```

### Output a Ninja build file

```
knit target -t commands ninja
```

### Output a compile commands database

```
knit target -t compdb
```

### Output a PDF build graph

```
knit target -t graph pdf > graph.pdf
```

# Built-in Lua functions

* `import(pkg string) table`: import a built-in package. Currently the only built-in package is `knit`.

* `rule(rule string)`: define a rule. The `$` syntax is shorthand for this function.

* `include(file string)`: run a Knitfile from its directory and return the generated ruleset.

* `rulefile(file string) Rule`: read a rule from a separate file and return it.

* `r{$ ...}`, `r(rules []Rule) RuleSet`: turn a table of rules into a ruleset.

* `tostring(value) string`: convert an arbitrary value to a string.

* `tobool(value)` bool: convert an arbitrary value to a boolean. A nil value
  will return nil, the strings `false`, `off`, or `0` will become false. A
  boolean will not be converted. Anything else will be true.

* `eval(code string): value`: evaluates a Lua expression in the global scope and returns the result.

* `f"..."`, `f(s string) string`: formats a string using `$var` or `$(var)` to
  expand variables. Does not expand expressions.

* `r{} + r{}`: you may use the `+` operator to combine rulesets together.

# The `knit` Lua package

The `knit` package can be imported with `import("knit")`, and provides the following functions:

* `repl(in []string, patstr, repl string) ([]string, error)`: replace all
  occurrences of the Go regular expression `patstr` with `repl` within `in`.

* `extrepl(in []string, ext, repl string) []string`: replace all occurrences of the
  literal string `ext` as a suffix with `repl` within `in`.

* `glob(pat string) []string`: return all files in the current working
  directory that match the glob `pat`.

* `shell(cmd string) string`: execute a command with the shell and return its
  output. If the command exits with an error the returned output will be the
  contents of the error.

* `trim(s string) string`: trim leading and trailing whitespace from a string.

* `abs(path string) (string, error)`: return the absolute path of a path.

* `readfile(path string) string`: returns the contents of a file, or nil if it
  does not exist.

* `os`: a string containing the operating system name.

* `arch`: a string containing the machine architecture name.

# CLI and environment variables

Variables may be set at the command-line when invoking Knit with the syntax
`var=value`. These variables will be available in the Knitfile in the `cli`
table. Environment variables are similarly available in the `env` table.
