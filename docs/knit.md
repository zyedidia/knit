# Rules

A rule consists of four parts:

* Targets: a list of values that are generated by this rule.
* Prereqs: a list of values that must be generated before this rule can be
  executed.
* Attributes: a list of flags that customize how this rule is interpreted.
* Recipe: a list of commands that are run to execute the rule.

The syntax for a rule is

```
targets:attributes: prereqs
    recipe
```

If the rule has no attributes, it may be omitted, leaving just `targets:
prereqs` on the first line.

When a rule is embedded in Lua, it is prefixed with a `$`:

```
$ targets:attributes: prereqs
    recipe
```

The rule continues until it is de-indented to the original indentation of the
`$`.

Direct rules are rules where the targets and prereqs are explicit names of
values. For example,

```
foo.o: foo.c
    gcc -c foo.c -o foo.o
```

Specifies that the file `foo.o` is built from `foo.c`, using the command `gcc
-c foo.c -o foo.o`.

## Meta rules

A meta rule is a special rule that describes a generic way to create direct
rules.  The meta rule describes how to match targets and prereqs into a direct
rule.  For example, a `%` meta rule uses `%` to match any sequence of
characters.

Thus the meta rule

```
%.o: %.c
    ...
```

describes that a direct rule

```
foo.o: foo.c
    ...
```

could be created. This direct rule would be created if another rule needed
`foo.o` to be generated.

Meta rules may also specify the match by using regular expressions, if the `R`
attribute is provided. For example:

```
foo-(.*)-(.*).tar.gz:R: $1/$2/foo
    ...
```

could create a direct rule

```
foo-linux-amd64.tar.gz: linux/amd64/foo
    ...
```

## Attributes

Knit supports the following attributes:

* `Q` (quiet): do not print this rule's recipe when executing.
* `R` (regex): this meta rule uses regular expression matching.
* `V` (virtual): the value this rule generates is not a file, just a name.
* `M` (no meta): this rule's targets cannot be matched by meta rules.
* `E` (non-stop): this rule does not stop if one of its commands fails.
* `B` (build): this rule must always be built (it is always out-of-date).
* `L` (linked): this rule always runs if an out-of-date sub-rule requires it as
  a prereq.
* `O` (order-only): this rule's prereqs are not considered automatically
  up-to-date even if this rule is up-to-date.

Attributes can also be applied to particular prerequisites rather than to an
entire rule, using the syntax `prereq[attributes]`. For example:

```
foo:V:
    echo foo
bar:V: foo[Q]
    echo bar
```

The `foo` rule will be quiet only when used as a prerequisite to the `bar`
rule.

## Recipes

A recipe is a list of commands to execute. They are executed within the `sh`
shell. Recipes may use variables that will be expanded before the recipe
executes. Variables are written with `$var`, or full Lua expressions can be
written with `$(expr)`. Variables/expressions are expanded eagerly when the
rule is created. If expansion causes an error, the expansion is delayed until
rule evaluation (when special build variables are available).

Some special variables are available during recipe expansion:

* `input`: a string of rule's prereqs.
* `inputs`: an array of this rule's prereqs.
* `output`: a string of this rule's targets.
* `outputs`: an array of this rule's targets.
* `match`: the value captured with `%` in a meta rule.
* `matches`: a list of matches captured by a regular expression meta rule.

Lua expressions should not mix uses of special build variables and Lua
global/local variables. This constraint may be relaxed in the future if it
turns out to be a useful feature.

# Knitfiles

A Knitfile is a Lua 5.1 program with additional support for rule expressions.
The Knitfile ultimately must return a "buildset" -- a list of build rules that
are used to construct the build graph.

A rule is defined in Lua with the `$` syntax:

```
$ targets:attributes: prereqs
    ...
```

A rule expression may be assigned to a variable

```
local rule = $ foo.o: foo.c
    gcc -c $input -o $output
```

More often, rule expressions are gathered together in a Lua table:

```
local rules = {
$ foo.o: foo.c
    gcc -c $input -o $output
$ foo: foo.o
    gcc $input -o $output
}
```

When you run `knit`, Knit will automatically look for a file called `Knitfile`
or `knitfile` (or you can specify a custom name with `-f`). Knit will look in
the current directory, and up to ancestor directories if one does not exist in
the current directory. This allows you to execute the build from anywhere in
your project without fragmenting the build system with multiple Knitfiles. You
can still make directory-specific targets that are namespaced relative to that
directory with sub-builds.

If you run `knit foo.o` from the `foo` directory, and there is a file
`../Knitfile` that defines a rule for building `foo/foo.o`, Knit will
automatically figure out that you mean to build `foo/foo.o` (relative to `..`),
since you specified `foo.o` (relative to `foo`). In other words, building
sub-files just works.

## Rulesets

A table of rules can be converted into a "ruleset" by using the special `r`
function, which converts the table into a Lua "userdata" object representing a
list of build rules.


```
local ruleset = r{
$ foo.o: foo.c
    gcc -c $input -o $output
$ foo: foo.o
    gcc $input -o $output
}
```

Note that two rulesets may be combined with the `+` operator.

```
ruleset = ruleset + r{
$ build:V: foo
}
```

# Buildsets

A buildset is a set of rules associated with a particular directory. A buildset
may also contain other buildsets (rules from other directories). All rules in
the buildset are executed relative to its directory. A buildset can be
constructed by using the special `b` function, which constructs a buildset from
a table of rules, rulesets, or other buildsets.

```
local buildset = b{
$ foo.o: foo.c
    gcc -c $input -o $output
$ foo: foo.o
    gcc $input -o $output
}
```

By default the buildset's directory is the current working directory when it is
constructed. A second argument may also be passed to `b` to directly specify the
build directory.

```
local buildset = b({
$ foo.o: foo.c
    gcc -c $input -o $output
$ foo: foo.o
    gcc $input -o $output
}, "directory")
```

A buildset must be returned by the Knitfile for a build to take place. When a
buildset is returned, knit expands it and all the buildsets that it returns
into the full set of rules, where each rule is relative to the buildset
directory that it came from. Rules may have cross-buildset dependencies.

These facilities for making rules relative to directories are for enabling
sub-builds, discussed in the next section.

## Sub-builds

A build may use several buildsets.

For example:

```lua
-- this buildset is relative to the "libfoo" directory
local foorules = b({
$ foo.o: foo.c
    gcc -c $input -o $output
}, "libfoo")

return b{
$ prog.o: prog.c
    gcc -c $input -o $output
-- libfoo/foo.o is automatically resolved to correspond to the rule in foorules
$ prog: prog.o libfoo/foo.o
    gcc $input -o $output

-- include the foorules buildset
foorules
}
```

This Knitfile assumes the build consists of `prog.c` and `libfoo/foo.c`. It
builds `libfoo/foo.o` using a sub-build and automatically determines that
the `foorules` buildset contains the rule for building `libfoo/foo.o`. Note
that the recipe for `foo.o` is run in the `libfoo` directory.

It is also useful to combine sub-builds with the `include(x)` function, which
runs the knit program `x` from the directory where it exists, and returns the
value that `x` produces. This means you can easily use a sub-directory's
Knitfile to create a buildset for use in a sub-build.

For example, for the previous build we could use the following file system
structure:

`libfoo/build.knit` contains:

```lua
-- this buildset's directory will be the current working directory
return b{
$ foo.o: foo.c
    gcc -c $input -o $output
}
```

`Knitfile` contains:

```lua
return b{
$ prog.o: prog.c
    gcc -c $input -o $output
-- libfoo/foo.o is automatically resolved to correspond to the rule in foorules
$ prog: prog.o libfoo/foo.o
    gcc $input -o $output

-- include the libfoo rules: this will change directory into libfoo, execute
-- build.knit, and change back to the current directory, thus giving us a buildset
-- for the libfoo directory automatically
include("libfoo/build.knit")
}
```

Note that since knit looks upwards for the nearest Knitfile, you can run `knit
foo.o` from inside `libfoo`, and knit will correctly build `libfoo/foo.o`.

Since managing the current working directory is important for easily creating
buildsets that automatically reference the correct directory, there are several
functions for this:

* `include(x)`: runs a Lua file from the directory where it exists.
* `dcall(fn, args)`: calls a Lua function from the directory where it is defined.
* `dcallfrom(dir, fn, args)`: calls a Lua function from a specified directory.
* `rel(files)`: makes all input files relative to the build's root directory.

# Options

Knit will search the current directory for a Knitfile called `knitfile` or
`Knitfile`. If one is not found, it will use the Knitfile in
`~/.config/knit/Knitfile.def`, or if that does not exist it will throw an
error.

Several options are available as command-line flags. They may also be specified
in a `.knit.toml` file. Knit will search upwards from the current directory
for `.knit.toml` files, and use the options set in those files. It will also
search `~/.config/knit/.knit.toml`.

## Sub-tools

Running `knit [TARGET]` will create a build graph for the target. By default,
knit will then execute that build graph. Using the `-t TOOL` option, you may
specify a sub-tool to run instead of building:

* `list` - list all available tools
* `graph` - print build graph in specified format: text, tree, dot, pdf
* `clean` - remove all files produced by the build
* `targets` - list all targets (pass 'virtual' for just virtual targets)
* `compdb` - output a compile commands database
* `commands` - output the build commands (formats: knit, json, make, ninja, shell)
* `status` - lists dependencies and whether they are up-to-date

The special target `:all` depends on every target in the build. Thus `knit :all
-t targets` will list all targets.

Some examples are shown below.

### Automatic cleaning

```
knit target -t clean
```

### Output a shell script for the build

```
knit target -t commands shell
```

### Output a Ninja build file

```
knit target -t commands ninja
```

### Output a compile commands database

```
knit target -t compdb
```

### Output a PDF build graph

```
knit target -t graph pdf > graph.pdf
```

# Built-in Lua functions

* `rule(rule string)`: define a rule. The `$` syntax is shorthand for this function.

* `include(file string)`: run a Knitfile from its directory and return the generated ruleset.

* `rulefile(file string) Rule`: read a rule from a separate file and return it.

* `r{$ ...}`, `r(rules []Rule) RuleSet`: turn a table of rules into a ruleset.

* `tostring(value) string`: convert an arbitrary value to a string.

* `tobool(value)` bool: convert an arbitrary value to a boolean. A nil value
  will return nil, the strings `false`, `off`, or `0` will become false. A
  boolean will not be converted. Anything else will be true.

* `eval(code string): value`: evaluates a Lua expression in the global scope and returns the result.

* `f"..."`, `f(s string) string`: formats a string using `$var` or `$(var)` to
  expand variables. Does not expand expressions.

* `r{} + r{}`: you may use the `+` operator to combine rulesets together.

# The `knit` Lua package

The `knit` package can be imported with `require("knit")`, and provides the following functions:

* `repl(in []string, patstr, repl string) ([]string, error)`: replace all
  occurrences of the Go regular expression `patstr` with `repl` within `in`.

* `extrepl(in []string, ext, repl string) []string`: replace all occurrences of the
  literal string `ext` as a suffix with `repl` within `in`.

* `glob(pat string) []string`: return all files in the current working
  directory that match the glob `pat`.

* `shell(cmd string) string`: execute a command with the shell and return its
  output. If the command exits with an error the returned output will be the
  contents of the error.

* `trim(s string) string`: trim leading and trailing whitespace from a string.

* `abs(path string) (string, error)`: return the absolute path of a path.

* `readfile(path string) string`: returns the contents of a file, or nil if it
  does not exist.

* `os`: a string containing the operating system name.

* `arch`: a string containing the machine architecture name.

# CLI and environment variables

Variables may be set at the command-line when invoking Knit with the syntax
`var=value`. These variables will be available in the Knitfile in the `cli`
table. Environment variables are similarly available in the `env` table.
